<!DOCTYPE html>
<html>

  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>共享锁：ReentrantReadWriteLock</title>
    <meta name="viewport" content="width=device-width">
    <meta name="description" content="You'll never walk alone.">
    <link rel="canonical" href="http://moonfacex.github.io/blog/java/2016/04/05/reentrantreadwritelock.html">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="http://moonfacex.github.io/blog/css/main.css">

</head>


    <body>

    <header class="site-header">

  <div class="wrap">

    <a class="site-title" href="http://moonfacex.github.io/blog">Moonface Space</a>

    <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
           viewBox="0 0 18 15" enable-background="new 0 0 18 15" xml:space="preserve">
          <path fill="#505050" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0
            h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#505050" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484
            h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#505050" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0
            c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>
      <div class="trigger">
        
          <a class="page-link" href="http://moonfacex.github.io/blog/about/">About</a>
        
          <a class="page-link" href="http://moonfacex.github.io/blog/feed.xml"></a>
        
          <a class="page-link" href="http://moonfacex.github.io/blog/index.html"></a>
        
      </div>
    </nav>

  </div>

</header>


    <div class="page-content">
      <div class="wrap">
      <div class="post">

  <header class="post-header">
    <h1>共享锁：ReentrantReadWriteLock</h1>
    <p class="meta">Apr 5, 2016</p>
  </header>

  <article class="post-content">
  <p>上一篇文章讲了ReentrantLock，我们知道它是一种互斥锁
但是要知道，ReentrantLock的本质其实是AbstractQueuedSynchronizer，而它不仅可以用来实现互斥锁，还能来实现共享锁
什么是共享锁？比如说对一个文件进行操作，对于写操作必须要用到互斥锁来保证数据唯一性，但是当读的时候呢，如果允许同时并行多个读操作，那将大大提高效率，只要保证所有的读操作与写操作之间互斥就可以了，读操作之间是可以共享的。
幸运的是，java.concurrent包中已经有了这种锁的实现，今天我们就来看看它到底是怎么做的吧。</p>

<div class="highlight"><pre><code class="java"><span class="lineno"> 1</span> <span class="kd">public</span> <span class="kd">class</span> <span class="nc">ReentrantReadWriteLock</span>
<span class="lineno"> 2</span>         <span class="kd">implements</span> <span class="n">ReadWriteLock</span><span class="o">,</span> <span class="n">java</span><span class="o">.</span><span class="na">io</span><span class="o">.</span><span class="na">Serializable</span> <span class="o">{</span>
<span class="lineno"> 3</span>     <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">serialVersionUID</span> <span class="o">=</span> <span class="o">-</span><span class="mi">6992448646407690164L</span><span class="o">;</span>
<span class="lineno"> 4</span>     <span class="cm">/** Inner class providing readlock */</span>
<span class="lineno"> 5</span>     <span class="kd">private</span> <span class="kd">final</span> <span class="n">ReentrantReadWriteLock</span><span class="o">.</span><span class="na">ReadLock</span> <span class="n">readerLock</span><span class="o">;</span>
<span class="lineno"> 6</span>     <span class="cm">/** Inner class providing writelock */</span>
<span class="lineno"> 7</span>     <span class="kd">private</span> <span class="kd">final</span> <span class="n">ReentrantReadWriteLock</span><span class="o">.</span><span class="na">WriteLock</span> <span class="n">writerLock</span><span class="o">;</span>
<span class="lineno"> 8</span>     <span class="cm">/** Performs all synchronization mechanics */</span>
<span class="lineno"> 9</span>     <span class="kd">final</span> <span class="n">Sync</span> <span class="n">sync</span><span class="o">;</span>
<span class="lineno">10</span> 
<span class="lineno">11</span>     <span class="cm">/**</span>
<span class="lineno">12</span> <span class="cm">     * Creates a new {@code ReentrantReadWriteLock} with</span>
<span class="lineno">13</span> <span class="cm">     * the given fairness policy.</span>
<span class="lineno">14</span> <span class="cm">     *</span>
<span class="lineno">15</span> <span class="cm">     * @param fair {@code true} if this lock should use a fair ordering policy</span>
<span class="lineno">16</span> <span class="cm">     */</span>
<span class="lineno">17</span>     <span class="kd">public</span> <span class="nf">ReentrantReadWriteLock</span><span class="o">(</span><span class="kt">boolean</span> <span class="n">fair</span><span class="o">)</span> <span class="o">{</span>
<span class="lineno">18</span>         <span class="n">sync</span> <span class="o">=</span> <span class="n">fair</span> <span class="o">?</span> <span class="k">new</span> <span class="n">FairSync</span><span class="o">()</span> <span class="o">:</span> <span class="k">new</span> <span class="n">NonfairSync</span><span class="o">();</span>
<span class="lineno">19</span>         <span class="n">readerLock</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ReadLock</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
<span class="lineno">20</span>         <span class="n">writerLock</span> <span class="o">=</span> <span class="k">new</span> <span class="n">WriteLock</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
<span class="lineno">21</span>     <span class="o">}</span>
<span class="lineno">22</span> <span class="o">}</span></code></pre></div>

<p>简单说一下，ReentrantReadWriteLock中有一个readrLock和一个writerLock，通过这它们可以实现读者写着之间的互斥以及共享操作
不过要注意，其实它们真正的实现都是那个熟悉的Sync。在ReentrantReadWriteLock中，有公平和非公平两种模式：在非公平模式下：当一个锁释放了，不能确定到底是writer等待线程获得写锁，还是readr等待线程们获得读锁；在公平模式下：一个锁释放了，选择等待最久的一个(组)线程获得锁，无论是writer线程还是reader线程们
这样看来，貌似其实整个ReentrantReadWriteLock里面只有一把锁，就是那个Sync！
下面开始揭秘，我们选择公平模式来分析，先看ReadLock的lock好了：</p>

<div class="highlight"><pre><code class="java"><span class="lineno"> 1</span> <span class="c1">// ReadLock</span>
<span class="lineno"> 2</span> <span class="cm">/**</span>
<span class="lineno"> 3</span> <span class="cm"> * Acquires the read lock.</span>
<span class="lineno"> 4</span> <span class="cm"> *</span>
<span class="lineno"> 5</span> <span class="cm"> * &lt;p&gt;Acquires the read lock if the write lock is not held by</span>
<span class="lineno"> 6</span> <span class="cm"> * another thread and returns immediately.</span>
<span class="lineno"> 7</span> <span class="cm"> *</span>
<span class="lineno"> 8</span> <span class="cm"> * &lt;p&gt;If the write lock is held by another thread then</span>
<span class="lineno"> 9</span> <span class="cm"> * the current thread becomes disabled for thread scheduling</span>
<span class="lineno">10</span> <span class="cm"> * purposes and lies dormant until the read lock has been acquired.</span>
<span class="lineno">11</span> <span class="cm"> */</span>
<span class="lineno">12</span> <span class="kd">public</span> <span class="kt">void</span> <span class="nf">lock</span><span class="o">()</span> <span class="o">{</span>
<span class="lineno">13</span>     <span class="n">sync</span><span class="o">.</span><span class="na">acquireShared</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
<span class="lineno">14</span> <span class="o">}</span>
<span class="lineno">15</span> 
<span class="lineno">16</span> <span class="c1">// AbstractQueuedSynchronizer</span>
<span class="lineno">17</span> <span class="kd">public</span> <span class="kd">final</span> <span class="kt">void</span> <span class="nf">acquireShared</span><span class="o">(</span><span class="kt">int</span> <span class="n">arg</span><span class="o">)</span> <span class="o">{</span>
<span class="lineno">18</span>     <span class="k">if</span> <span class="o">(</span><span class="n">tryAcquireShared</span><span class="o">(</span><span class="n">arg</span><span class="o">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span>
<span class="lineno">19</span>         <span class="n">doAcquireShared</span><span class="o">(</span><span class="n">arg</span><span class="o">);</span>
<span class="lineno">20</span> <span class="o">}</span></code></pre></div>

<p>他会调用AbstractQueuedSynchronizer里的acquireShared，后者会先调用Sync里的tryAcquireShared:</p>

<div class="highlight"><pre><code class="java"><span class="lineno"> 1</span> <span class="c1">// Sync in ReetrantReadWriteLock</span>
<span class="lineno"> 2</span> 
<span class="lineno"> 3</span> <span class="kd">protected</span> <span class="kd">final</span> <span class="kt">int</span> <span class="nf">tryAcquireShared</span><span class="o">(</span><span class="kt">int</span> <span class="n">unused</span><span class="o">)</span> <span class="o">{</span>
<span class="lineno"> 4</span>     <span class="n">Thread</span> <span class="n">current</span> <span class="o">=</span> <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">();</span>
<span class="lineno"> 5</span>     <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">getState</span><span class="o">();</span>
<span class="lineno"> 6</span>     <span class="k">if</span> <span class="o">(</span><span class="n">exclusiveCount</span><span class="o">(</span><span class="n">c</span><span class="o">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
<span class="lineno"> 7</span>         <span class="n">getExclusiveOwnerThread</span><span class="o">()</span> <span class="o">!=</span> <span class="n">current</span><span class="o">)</span>
<span class="lineno"> 8</span>         <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
<span class="lineno"> 9</span>     <span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="n">sharedCount</span><span class="o">(</span><span class="n">c</span><span class="o">);</span>
<span class="lineno">10</span>     <span class="k">if</span> <span class="o">(!</span><span class="n">readerShouldBlock</span><span class="o">()</span> <span class="o">&amp;&amp;</span>
<span class="lineno">11</span>         <span class="n">r</span> <span class="o">&lt;</span> <span class="n">MAX_COUNT</span> <span class="o">&amp;&amp;</span>
<span class="lineno">12</span>         <span class="n">compareAndSetState</span><span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="n">c</span> <span class="o">+</span> <span class="n">SHARED_UNIT</span><span class="o">))</span> <span class="o">{</span>
<span class="lineno">13</span>         <span class="k">if</span> <span class="o">(</span><span class="n">r</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
<span class="lineno">14</span>             <span class="n">firstReader</span> <span class="o">=</span> <span class="n">current</span><span class="o">;</span>
<span class="lineno">15</span>             <span class="n">firstReaderHoldCount</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
<span class="lineno">16</span>         <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">firstReader</span> <span class="o">==</span> <span class="n">current</span><span class="o">)</span> <span class="o">{</span>
<span class="lineno">17</span>             <span class="n">firstReaderHoldCount</span><span class="o">++;</span>
<span class="lineno">18</span>         <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
<span class="lineno">19</span>             <span class="n">HoldCounter</span> <span class="n">rh</span> <span class="o">=</span> <span class="n">cachedHoldCounter</span><span class="o">;</span>
<span class="lineno">20</span>             <span class="k">if</span> <span class="o">(</span><span class="n">rh</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">rh</span><span class="o">.</span><span class="na">tid</span> <span class="o">!=</span> <span class="n">current</span><span class="o">.</span><span class="na">getId</span><span class="o">())</span>
<span class="lineno">21</span>                 <span class="n">cachedHoldCounter</span> <span class="o">=</span> <span class="n">rh</span> <span class="o">=</span> <span class="n">readHolds</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
<span class="lineno">22</span>             <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">rh</span><span class="o">.</span><span class="na">count</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
<span class="lineno">23</span>                 <span class="n">readHolds</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">rh</span><span class="o">);</span>
<span class="lineno">24</span>             <span class="n">rh</span><span class="o">.</span><span class="na">count</span><span class="o">++;</span>
<span class="lineno">25</span>         <span class="o">}</span>
<span class="lineno">26</span>         <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
<span class="lineno">27</span>     <span class="o">}</span>
<span class="lineno">28</span>     <span class="k">return</span> <span class="nf">fullTryAcquireShared</span><span class="o">(</span><span class="n">current</span><span class="o">);</span>
<span class="lineno">29</span> <span class="o">}</span></code></pre></div>

<ul>
  <li>第3行的if先判断write重入锁的次数以及当前的独占线程是不是自己，若果都不满足，说明writer正在持有锁，返回负值表示失败</li>
  <li>第7行会先判断读者是否应该被阻塞，至此，应该知道当前是readers获得了锁，因此就尝试通过CAS增加一个reader，最后只要用一个ThreadLocal类型的readHolds来记录当前线程的重入次数就行了</li>
  <li>如果上面条件都不成立，会进入fullTryAcquireShared</li>
</ul>

<p>不过我们先来看看readerShouldBlock做了什么：
非公平状态下会调用AbstractQueuedSynchronizer中的：</p>

<div class="highlight"><pre><code class="java"><span class="lineno"> 1</span> <span class="cm">/**</span>
<span class="lineno"> 2</span> <span class="cm"> * Returns {@code true} if the apparent first queued thread, if one</span>
<span class="lineno"> 3</span> <span class="cm"> * exists, is waiting in exclusive mode.  If this method returns</span>
<span class="lineno"> 4</span> <span class="cm"> * {@code true}, and the current thread is attempting to acquire in</span>
<span class="lineno"> 5</span> <span class="cm"> * shared mode (that is, this method is invoked from {@link</span>
<span class="lineno"> 6</span> <span class="cm"> * #tryAcquireShared}) then it is guaranteed that the current thread</span>
<span class="lineno"> 7</span> <span class="cm"> * is not the first queued thread.  Used only as a heuristic in</span>
<span class="lineno"> 8</span> <span class="cm"> * ReentrantReadWriteLock.</span>
<span class="lineno"> 9</span> <span class="cm"> */</span>
<span class="lineno">10</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">apparentlyFirstQueuedIsExclusive</span><span class="o">()</span> <span class="o">{</span>
<span class="lineno">11</span>     <span class="n">Node</span> <span class="n">h</span><span class="o">,</span> <span class="n">s</span><span class="o">;</span>
<span class="lineno">12</span>     <span class="k">return</span> <span class="o">(</span><span class="n">h</span> <span class="o">=</span> <span class="n">head</span><span class="o">)</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span>
<span class="lineno">13</span>         <span class="o">(</span><span class="n">s</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="na">next</span><span class="o">)</span>  <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span>
<span class="lineno">14</span>         <span class="o">!</span><span class="n">s</span><span class="o">.</span><span class="na">isShared</span><span class="o">()</span>         <span class="o">&amp;&amp;</span>
<span class="lineno">15</span>         <span class="n">s</span><span class="o">.</span><span class="na">thread</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">;</span>
<span class="lineno">16</span> <span class="o">}</span></code></pre></div>

<p>意思就是CLH中有一个等待获取锁的node，并且它不是share模式的(这很重要)，这就代表着它会考虑writer线程，不会让writer线程永远等下去，因此writer排在第一位(head是锁持有者，head.next是第一个等待者)的时候，会返回true，告诉当前线程，应该block，如果是个reader那就不用等了这就是非公平的含义
顺个便来看一下公平模式中是怎么做的：</p>

<div class="highlight"><pre><code class="java"><span class="lineno">1</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">FairSync</span> <span class="kd">extends</span> <span class="n">Sync</span> <span class="o">{</span>
<span class="lineno">2</span>     <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">long</span> <span class="n">serialVersionUID</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2274990926593161451L</span><span class="o">;</span>
<span class="lineno">3</span>     <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">writerShouldBlock</span><span class="o">()</span> <span class="o">{</span>
<span class="lineno">4</span>         <span class="k">return</span> <span class="nf">hasQueuedPredecessors</span><span class="o">();</span>
<span class="lineno">5</span>     <span class="o">}</span>
<span class="lineno">6</span>     <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">readerShouldBlock</span><span class="o">()</span> <span class="o">{</span>
<span class="lineno">7</span>         <span class="k">return</span> <span class="nf">hasQueuedPredecessors</span><span class="o">();</span>
<span class="lineno">8</span>     <span class="o">}</span>
<span class="lineno">9</span> <span class="o">}</span></code></pre></div>

<p>啊哈，就是看是否有一个node正在等待获得锁，它不考虑是否是share模式还是非share模式，这就是所谓的公平
回过头来再看fullTryAcquireShared，也就是有机会获得锁但是又无法获得锁的情况(无论是别的thread优先级比自己高，还是reader数量超MAX或者是CAS失败)：</p>

<div class="highlight"><pre><code class="java"><span class="lineno"> 1</span> <span class="kd">final</span> <span class="kt">int</span> <span class="nf">fullTryAcquireShared</span><span class="o">(</span><span class="n">Thread</span> <span class="n">current</span><span class="o">)</span> <span class="o">{</span>
<span class="lineno"> 2</span>     <span class="cm">/*</span>
<span class="lineno"> 3</span> <span class="cm">     * This code is in part redundant with that in</span>
<span class="lineno"> 4</span> <span class="cm">     * tryAcquireShared but is simpler overall by not</span>
<span class="lineno"> 5</span> <span class="cm">     * complicating tryAcquireShared with interactions between</span>
<span class="lineno"> 6</span> <span class="cm">     * retries and lazily reading hold counts.</span>
<span class="lineno"> 7</span> <span class="cm">     */</span>
<span class="lineno"> 8</span>     <span class="n">HoldCounter</span> <span class="n">rh</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
<span class="lineno"> 9</span>     <span class="k">for</span> <span class="o">(;;)</span> <span class="o">{</span>
<span class="lineno">10</span>         <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">getState</span><span class="o">();</span>
<span class="lineno">11</span>         <span class="k">if</span> <span class="o">(</span><span class="n">exclusiveCount</span><span class="o">(</span><span class="n">c</span><span class="o">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
<span class="lineno">12</span>             <span class="k">if</span> <span class="o">(</span><span class="n">getExclusiveOwnerThread</span><span class="o">()</span> <span class="o">!=</span> <span class="n">current</span><span class="o">)</span>
<span class="lineno">13</span>                 <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
<span class="lineno">14</span>             <span class="c1">// else we hold the exclusive lock; blocking here</span>
<span class="lineno">15</span>             <span class="c1">// would cause deadlock.</span>
<span class="lineno">16</span>         <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">readerShouldBlock</span><span class="o">())</span> <span class="o">{</span>
<span class="lineno">17</span>             <span class="c1">// Make sure we&#39;re not acquiring read lock reentrantly</span>
<span class="lineno">18</span>             <span class="k">if</span> <span class="o">(</span><span class="n">firstReader</span> <span class="o">==</span> <span class="n">current</span><span class="o">)</span> <span class="o">{</span>
<span class="lineno">19</span>                 <span class="c1">// assert firstReaderHoldCount &gt; 0;</span>
<span class="lineno">20</span>             <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
<span class="lineno">21</span>                 <span class="k">if</span> <span class="o">(</span><span class="n">rh</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
<span class="lineno">22</span>                     <span class="n">rh</span> <span class="o">=</span> <span class="n">cachedHoldCounter</span><span class="o">;</span>
<span class="lineno">23</span>                     <span class="k">if</span> <span class="o">(</span><span class="n">rh</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">rh</span><span class="o">.</span><span class="na">tid</span> <span class="o">!=</span> <span class="n">current</span><span class="o">.</span><span class="na">getId</span><span class="o">())</span> <span class="o">{</span>
<span class="lineno">24</span>                         <span class="n">rh</span> <span class="o">=</span> <span class="n">readHolds</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
<span class="lineno">25</span>                         <span class="k">if</span> <span class="o">(</span><span class="n">rh</span><span class="o">.</span><span class="na">count</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
<span class="lineno">26</span>                             <span class="n">readHolds</span><span class="o">.</span><span class="na">remove</span><span class="o">();</span>
<span class="lineno">27</span>                     <span class="o">}</span>
<span class="lineno">28</span>                 <span class="o">}</span>
<span class="lineno">29</span>                 <span class="k">if</span> <span class="o">(</span><span class="n">rh</span><span class="o">.</span><span class="na">count</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
<span class="lineno">30</span>                     <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
<span class="lineno">31</span>             <span class="o">}</span>
<span class="lineno">32</span>         <span class="o">}</span>
<span class="lineno">33</span>         <span class="k">if</span> <span class="o">(</span><span class="n">sharedCount</span><span class="o">(</span><span class="n">c</span><span class="o">)</span> <span class="o">==</span> <span class="n">MAX_COUNT</span><span class="o">)</span>
<span class="lineno">34</span>             <span class="k">throw</span> <span class="k">new</span> <span class="nf">Error</span><span class="o">(</span><span class="s">&quot;Maximum lock count exceeded&quot;</span><span class="o">);</span>
<span class="lineno">35</span>         <span class="k">if</span> <span class="o">(</span><span class="n">compareAndSetState</span><span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="n">c</span> <span class="o">+</span> <span class="n">SHARED_UNIT</span><span class="o">))</span> <span class="o">{</span>
<span class="lineno">36</span>             <span class="k">if</span> <span class="o">(</span><span class="n">sharedCount</span><span class="o">(</span><span class="n">c</span><span class="o">)</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
<span class="lineno">37</span>                 <span class="n">firstReader</span> <span class="o">=</span> <span class="n">current</span><span class="o">;</span>
<span class="lineno">38</span>                 <span class="n">firstReaderHoldCount</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
<span class="lineno">39</span>             <span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">firstReader</span> <span class="o">==</span> <span class="n">current</span><span class="o">)</span> <span class="o">{</span>
<span class="lineno">40</span>                 <span class="n">firstReaderHoldCount</span><span class="o">++;</span>
<span class="lineno">41</span>             <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
<span class="lineno">42</span>                 <span class="k">if</span> <span class="o">(</span><span class="n">rh</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
<span class="lineno">43</span>                     <span class="n">rh</span> <span class="o">=</span> <span class="n">cachedHoldCounter</span><span class="o">;</span>
<span class="lineno">44</span>                 <span class="k">if</span> <span class="o">(</span><span class="n">rh</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">rh</span><span class="o">.</span><span class="na">tid</span> <span class="o">!=</span> <span class="n">current</span><span class="o">.</span><span class="na">getId</span><span class="o">())</span>
<span class="lineno">45</span>                     <span class="n">rh</span> <span class="o">=</span> <span class="n">readHolds</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
<span class="lineno">46</span>                 <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">rh</span><span class="o">.</span><span class="na">count</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
<span class="lineno">47</span>                     <span class="n">readHolds</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">rh</span><span class="o">);</span>
<span class="lineno">48</span>                 <span class="n">rh</span><span class="o">.</span><span class="na">count</span><span class="o">++;</span>
<span class="lineno">49</span>                 <span class="n">cachedHoldCounter</span> <span class="o">=</span> <span class="n">rh</span><span class="o">;</span> <span class="c1">// cache for release</span>
<span class="lineno">50</span>             <span class="o">}</span>
<span class="lineno">51</span>             <span class="k">return</span> <span class="mi">1</span><span class="o">;</span>
<span class="lineno">52</span>         <span class="o">}</span>
<span class="lineno">53</span>     <span class="o">}</span>
<span class="lineno">54</span> <span class="o">}</span></code></pre></div>

<p>注释也说了，我们也看到了，整个逻辑几乎跟tryAcquireShared一模一样，只不过加了无限循环保证CAS成功。
值得注意的是，唯一不同之处在于16行的else，在有别的线程等待获取锁的状态下(且它们的优先级更高)，如果当前所有readers都释放锁的话(cachedHold
.count == 0) 那么当前线程也不会再去抢夺这个锁了，返回-1；如果当前还有readers占有锁，那么本线程也不客气，还是会去尝试CAS，毕竟现在是readers的天下</p>

<p>好了，如果当前线程没有成功拿到锁，那么回到acquireShared中去做doAcquireShared：</p>

<div class="highlight"><pre><code class="java"><span class="lineno"> 1</span> <span class="cm">/**</span>
<span class="lineno"> 2</span> <span class="cm"> * Acquires in shared uninterruptible mode.</span>
<span class="lineno"> 3</span> <span class="cm"> * @param arg the acquire argument</span>
<span class="lineno"> 4</span> <span class="cm"> */</span>
<span class="lineno"> 5</span> <span class="kd">private</span> <span class="kt">void</span> <span class="nf">doAcquireShared</span><span class="o">(</span><span class="kt">int</span> <span class="n">arg</span><span class="o">)</span> <span class="o">{</span>
<span class="lineno"> 6</span>     <span class="kd">final</span> <span class="n">Node</span> <span class="n">node</span> <span class="o">=</span> <span class="n">addWaiter</span><span class="o">(</span><span class="n">Node</span><span class="o">.</span><span class="na">SHARED</span><span class="o">);</span>
<span class="lineno"> 7</span>     <span class="kt">boolean</span> <span class="n">failed</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
<span class="lineno"> 8</span>     <span class="k">try</span> <span class="o">{</span>
<span class="lineno"> 9</span>         <span class="kt">boolean</span> <span class="n">interrupted</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
<span class="lineno">10</span>         <span class="k">for</span> <span class="o">(;;)</span> <span class="o">{</span>
<span class="lineno">11</span>             <span class="kd">final</span> <span class="n">Node</span> <span class="n">p</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">predecessor</span><span class="o">();</span>
<span class="lineno">12</span>             <span class="k">if</span> <span class="o">(</span><span class="n">p</span> <span class="o">==</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>
<span class="lineno">13</span>                 <span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="n">tryAcquireShared</span><span class="o">(</span><span class="n">arg</span><span class="o">);</span>
<span class="lineno">14</span>                 <span class="k">if</span> <span class="o">(</span><span class="n">r</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
<span class="lineno">15</span>                     <span class="n">setHeadAndPropagate</span><span class="o">(</span><span class="n">node</span><span class="o">,</span> <span class="n">r</span><span class="o">);</span>
<span class="lineno">16</span>                     <span class="n">p</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span> <span class="c1">// help GC</span>
<span class="lineno">17</span>                     <span class="k">if</span> <span class="o">(</span><span class="n">interrupted</span><span class="o">)</span>
<span class="lineno">18</span>                         <span class="n">selfInterrupt</span><span class="o">();</span>
<span class="lineno">19</span>                     <span class="n">failed</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
<span class="lineno">20</span>                     <span class="k">return</span><span class="o">;</span>
<span class="lineno">21</span>                 <span class="o">}</span>
<span class="lineno">22</span>             <span class="o">}</span>
<span class="lineno">23</span>             <span class="k">if</span> <span class="o">(</span><span class="n">shouldParkAfterFailedAcquire</span><span class="o">(</span><span class="n">p</span><span class="o">,</span> <span class="n">node</span><span class="o">)</span> <span class="o">&amp;&amp;</span>
<span class="lineno">24</span>                 <span class="n">parkAndCheckInterrupt</span><span class="o">())</span>
<span class="lineno">25</span>                 <span class="n">interrupted</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
<span class="lineno">26</span>         <span class="o">}</span>
<span class="lineno">27</span>     <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
<span class="lineno">28</span>         <span class="k">if</span> <span class="o">(</span><span class="n">failed</span><span class="o">)</span>
<span class="lineno">29</span>             <span class="n">cancelAcquire</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>
<span class="lineno">30</span>     <span class="o">}</span>
<span class="lineno">31</span> <span class="o">}</span></code></pre></div>

<p>有没有很熟悉？跟ReentrantLock的acquireQueued如出一辙，不同的是这里调用了setHeadAndPropagate，就是要把后面连续的readers都唤醒，因为这里已经是readers的天下啦
不过要注意的是,这里addWaiter中，会把当前node标记为share状态，那么在之前的非公平模式的readerShouldBlock中检查到等待的是一个reader，那就会返回false，代表它不会考虑别的在等待的readers的感受，而公平模式中会检查这个标记，代表别的等待状态的readers有机会使当前获得锁的readers进入block状态</p>

<p>上锁讲完了，接下来看看readers是怎么unlock的：</p>

<div class="highlight"><pre><code class="java"><span class="lineno"> 1</span> <span class="c1">// ReadLock</span>
<span class="lineno"> 2</span> <span class="cm">/**</span>
<span class="lineno"> 3</span> <span class="cm"> * Attempts to release this lock.</span>
<span class="lineno"> 4</span> <span class="cm"> *</span>
<span class="lineno"> 5</span> <span class="cm"> * &lt;p&gt; If the number of readers is now zero then the lock</span>
<span class="lineno"> 6</span> <span class="cm"> * is made available for write lock attempts.</span>
<span class="lineno"> 7</span> <span class="cm"> */</span>
<span class="lineno"> 8</span>  <span class="kd">public</span>  <span class="kt">void</span> <span class="nf">unlock</span><span class="o">()</span> <span class="o">{</span>
<span class="lineno"> 9</span>      <span class="n">sync</span><span class="o">.</span><span class="na">releaseShared</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
<span class="lineno">10</span> <span class="o">}</span>
<span class="lineno">11</span> 
<span class="lineno">12</span> <span class="c1">// AbstractQueuedSynchronizer</span>
<span class="lineno">13</span> <span class="cm">/**</span>
<span class="lineno">14</span> <span class="cm"> * Releases in shared mode.  Implemented by unblocking one or more</span>
<span class="lineno">15</span> <span class="cm"> * threads if {@link #tryReleaseShared} returns true.</span>
<span class="lineno">16</span> <span class="cm"> *</span>
<span class="lineno">17</span> <span class="cm"> * @param arg the release argument.  This value is conveyed to</span>
<span class="lineno">18</span> <span class="cm"> *        {@link #tryReleaseShared} but is otherwise uninterpreted</span>
<span class="lineno">19</span> <span class="cm"> *        and can represent anything you like.</span>
<span class="lineno">20</span> <span class="cm"> * @return the value returned from {@link #tryReleaseShared}</span>
<span class="lineno">21</span> <span class="cm"> */</span>
<span class="lineno">22</span> <span class="kd">public</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">releaseShared</span><span class="o">(</span><span class="kt">int</span> <span class="n">arg</span><span class="o">)</span> <span class="o">{</span>
<span class="lineno">23</span>     <span class="k">if</span> <span class="o">(</span><span class="n">tryReleaseShared</span><span class="o">(</span><span class="n">arg</span><span class="o">))</span> <span class="o">{</span>
<span class="lineno">24</span>         <span class="n">doReleaseShared</span><span class="o">();</span>
<span class="lineno">25</span>         <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
<span class="lineno">26</span>     <span class="o">}</span>
<span class="lineno">27</span>     <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
<span class="lineno">28</span> <span class="o">}</span></code></pre></div>

<p>还是先来看看Sync的tryRelease吧，这就没有公平不公平之分了：</p>

<div class="highlight"><pre><code class="java"><span class="lineno"> 1</span> <span class="kd">protected</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">tryReleaseShared</span><span class="o">(</span><span class="kt">int</span> <span class="n">unused</span><span class="o">)</span> <span class="o">{</span>
<span class="lineno"> 2</span>     <span class="n">Thread</span> <span class="n">current</span> <span class="o">=</span> <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">();</span>
<span class="lineno"> 3</span>     <span class="k">if</span> <span class="o">(</span><span class="n">firstReader</span> <span class="o">==</span> <span class="n">current</span><span class="o">)</span> <span class="o">{</span>
<span class="lineno"> 4</span>         <span class="c1">// assert firstReaderHoldCount &gt; 0;</span>
<span class="lineno"> 5</span>         <span class="k">if</span> <span class="o">(</span><span class="n">firstReaderHoldCount</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span>
<span class="lineno"> 6</span>             <span class="n">firstReader</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
<span class="lineno"> 7</span>         <span class="k">else</span>
<span class="lineno"> 8</span>             <span class="n">firstReaderHoldCount</span><span class="o">--;</span>
<span class="lineno"> 9</span>     <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
<span class="lineno">10</span>         <span class="n">HoldCounter</span> <span class="n">rh</span> <span class="o">=</span> <span class="n">cachedHoldCounter</span><span class="o">;</span>
<span class="lineno">11</span>         <span class="k">if</span> <span class="o">(</span><span class="n">rh</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">rh</span><span class="o">.</span><span class="na">tid</span> <span class="o">!=</span> <span class="n">current</span><span class="o">.</span><span class="na">getId</span><span class="o">())</span>
<span class="lineno">12</span>             <span class="n">rh</span> <span class="o">=</span> <span class="n">readHolds</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
<span class="lineno">13</span>         <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="n">rh</span><span class="o">.</span><span class="na">count</span><span class="o">;</span>
<span class="lineno">14</span>         <span class="k">if</span> <span class="o">(</span><span class="n">count</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
<span class="lineno">15</span>             <span class="n">readHolds</span><span class="o">.</span><span class="na">remove</span><span class="o">();</span>
<span class="lineno">16</span>             <span class="k">if</span> <span class="o">(</span><span class="n">count</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">)</span>
<span class="lineno">17</span>                 <span class="k">throw</span> <span class="nf">unmatchedUnlockException</span><span class="o">();</span>
<span class="lineno">18</span>         <span class="o">}</span>
<span class="lineno">19</span>         <span class="o">--</span><span class="n">rh</span><span class="o">.</span><span class="na">count</span><span class="o">;</span>
<span class="lineno">20</span>     <span class="o">}</span>
<span class="lineno">21</span>     <span class="k">for</span> <span class="o">(;;)</span> <span class="o">{</span>
<span class="lineno">22</span>         <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">getState</span><span class="o">();</span>
<span class="lineno">23</span>         <span class="kt">int</span> <span class="n">nextc</span> <span class="o">=</span> <span class="n">c</span> <span class="o">-</span> <span class="n">SHARED_UNIT</span><span class="o">;</span>
<span class="lineno">24</span>         <span class="k">if</span> <span class="o">(</span><span class="n">compareAndSetState</span><span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="n">nextc</span><span class="o">))</span>
<span class="lineno">25</span>             <span class="c1">// Releasing the read lock has no effect on readers,</span>
<span class="lineno">26</span>             <span class="c1">// but it may allow waiting writers to proceed if</span>
<span class="lineno">27</span>             <span class="c1">// both read and write locks are now free.</span>
<span class="lineno">28</span>             <span class="k">return</span> <span class="n">nextc</span> <span class="o">==</span> <span class="mi">0</span><span class="o">;</span>
<span class="lineno">29</span>     <span class="o">}</span>
<span class="lineno">30</span> <span class="o">}</span></code></pre></div>

<p>还是CAS操作，很简单，不过要注意的是cachedHoldCounter，这就是为什么之前的tryAcquireShared里面要用到它的原因了，它能够反映最近一次release的情况
当全部readers(包括自己的重入)都release完之后，进入AbstractQueuedSynchronizer的doRelease：</p>

<div class="highlight"><pre><code class="java"><span class="lineno"> 1</span> <span class="cm">/**</span>
<span class="lineno"> 2</span> <span class="cm"> * Release action for shared mode -- signal successor and ensure</span>
<span class="lineno"> 3</span> <span class="cm"> * propagation. (Note: For exclusive mode, release just amounts</span>
<span class="lineno"> 4</span> <span class="cm"> * to calling unparkSuccessor of head if it needs signal.)</span>
<span class="lineno"> 5</span> <span class="cm"> */</span>
<span class="lineno"> 6</span> <span class="kd">private</span> <span class="kt">void</span> <span class="nf">doReleaseShared</span><span class="o">()</span> <span class="o">{</span>
<span class="lineno"> 7</span>     <span class="cm">/*</span>
<span class="lineno"> 8</span> <span class="cm">     * Ensure that a release propagates, even if there are other</span>
<span class="lineno"> 9</span> <span class="cm">     * in-progress acquires/releases.  This proceeds in the usual</span>
<span class="lineno">10</span> <span class="cm">     * way of trying to unparkSuccessor of head if it needs</span>
<span class="lineno">11</span> <span class="cm">     * signal. But if it does not, status is set to PROPAGATE to</span>
<span class="lineno">12</span> <span class="cm">     * ensure that upon release, propagation continues.</span>
<span class="lineno">13</span> <span class="cm">     * Additionally, we must loop in case a new node is added</span>
<span class="lineno">14</span> <span class="cm">     * while we are doing this. Also, unlike other uses of</span>
<span class="lineno">15</span> <span class="cm">     * unparkSuccessor, we need to know if CAS to reset status</span>
<span class="lineno">16</span> <span class="cm">     * fails, if so rechecking.</span>
<span class="lineno">17</span> <span class="cm">     */</span>
<span class="lineno">18</span>     <span class="k">for</span> <span class="o">(;;)</span> <span class="o">{</span>
<span class="lineno">19</span>         <span class="n">Node</span> <span class="n">h</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
<span class="lineno">20</span>         <span class="k">if</span> <span class="o">(</span><span class="n">h</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">h</span> <span class="o">!=</span> <span class="n">tail</span><span class="o">)</span> <span class="o">{</span>
<span class="lineno">21</span>             <span class="kt">int</span> <span class="n">ws</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="na">waitStatus</span><span class="o">;</span>
<span class="lineno">22</span>             <span class="k">if</span> <span class="o">(</span><span class="n">ws</span> <span class="o">==</span> <span class="n">Node</span><span class="o">.</span><span class="na">SIGNAL</span><span class="o">)</span> <span class="o">{</span>
<span class="lineno">23</span>                 <span class="k">if</span> <span class="o">(!</span><span class="n">compareAndSetWaitStatus</span><span class="o">(</span><span class="n">h</span><span class="o">,</span> <span class="n">Node</span><span class="o">.</span><span class="na">SIGNAL</span><span class="o">,</span> <span class="mi">0</span><span class="o">))</span>
<span class="lineno">24</span>                     <span class="k">continue</span><span class="o">;</span>            <span class="c1">// loop to recheck cases</span>
<span class="lineno">25</span>                 <span class="n">unparkSuccessor</span><span class="o">(</span><span class="n">h</span><span class="o">);</span>
<span class="lineno">26</span>             <span class="o">}</span>
<span class="lineno">27</span>             <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">ws</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
<span class="lineno">28</span>                      <span class="o">!</span><span class="n">compareAndSetWaitStatus</span><span class="o">(</span><span class="n">h</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">Node</span><span class="o">.</span><span class="na">PROPAGATE</span><span class="o">))</span>
<span class="lineno">29</span>                 <span class="k">continue</span><span class="o">;</span>                <span class="c1">// loop on failed CAS</span>
<span class="lineno">30</span>         <span class="o">}</span>
<span class="lineno">31</span>         <span class="k">if</span> <span class="o">(</span><span class="n">h</span> <span class="o">==</span> <span class="n">head</span><span class="o">)</span>                   <span class="c1">// loop if head changed</span>
<span class="lineno">32</span>             <span class="k">break</span><span class="o">;</span>
<span class="lineno">33</span>     <span class="o">}</span>
<span class="lineno">34</span> <span class="o">}</span></code></pre></div>

<p>如果后继节点需要被唤醒那就唤醒咯，如果不需要，就把它标记为PROPAGATE来告诉后面的节点所有readers都unlock了
不过有人要问了，为什么要用一个for循环还要用CAS呢？难道有人在跟它做同样的事？没错，就是之前doAcquireShared里面的setHeadAndPropagate：</p>

<div class="highlight"><pre><code class="java"><span class="lineno"> 1</span> <span class="cm">/**</span>
<span class="lineno"> 2</span> <span class="cm"> * Sets head of queue, and checks if successor may be waiting</span>
<span class="lineno"> 3</span> <span class="cm"> * in shared mode, if so propagating if either propagate &gt; 0 or</span>
<span class="lineno"> 4</span> <span class="cm"> * PROPAGATE status was set.</span>
<span class="lineno"> 5</span> <span class="cm"> *</span>
<span class="lineno"> 6</span> <span class="cm"> * @param node the node</span>
<span class="lineno"> 7</span> <span class="cm"> * @param propagate the return value from a tryAcquireShared</span>
<span class="lineno"> 8</span> <span class="cm"> */</span>
<span class="lineno"> 9</span> <span class="kd">private</span> <span class="kt">void</span> <span class="nf">setHeadAndPropagate</span><span class="o">(</span><span class="n">Node</span> <span class="n">node</span><span class="o">,</span> <span class="kt">int</span> <span class="n">propagate</span><span class="o">)</span> <span class="o">{</span>
<span class="lineno">10</span>     <span class="n">Node</span> <span class="n">h</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span> <span class="c1">// Record old head for check below</span>
<span class="lineno">11</span>     <span class="n">setHead</span><span class="o">(</span><span class="n">node</span><span class="o">);</span>
<span class="lineno">12</span>     <span class="cm">/*</span>
<span class="lineno">13</span> <span class="cm">     * Try to signal next queued node if:</span>
<span class="lineno">14</span> <span class="cm">     *   Propagation was indicated by caller,</span>
<span class="lineno">15</span> <span class="cm">     *     or was recorded (as h.waitStatus) by a previous operation</span>
<span class="lineno">16</span> <span class="cm">     *     (note: this uses sign-check of waitStatus because</span>
<span class="lineno">17</span> <span class="cm">     *      PROPAGATE status may transition to SIGNAL.)</span>
<span class="lineno">18</span> <span class="cm">     * and</span>
<span class="lineno">19</span> <span class="cm">     *   The next node is waiting in shared mode,</span>
<span class="lineno">20</span> <span class="cm">     *     or we don&#39;t know, because it appears null</span>
<span class="lineno">21</span> <span class="cm">     *</span>
<span class="lineno">22</span> <span class="cm">     * The conservatism in both of these checks may cause</span>
<span class="lineno">23</span> <span class="cm">     * unnecessary wake-ups, but only when there are multiple</span>
<span class="lineno">24</span> <span class="cm">     * racing acquires/releases, so most need signals now or soon</span>
<span class="lineno">25</span> <span class="cm">     * anyway.</span>
<span class="lineno">26</span> <span class="cm">     */</span>
<span class="lineno">27</span>     <span class="k">if</span> <span class="o">(</span><span class="n">propagate</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">h</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">h</span><span class="o">.</span><span class="na">waitStatus</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
<span class="lineno">28</span>         <span class="n">Node</span> <span class="n">s</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
<span class="lineno">29</span>         <span class="k">if</span> <span class="o">(</span><span class="n">s</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">s</span><span class="o">.</span><span class="na">isShared</span><span class="o">())</span>
<span class="lineno">30</span>             <span class="n">doReleaseShared</span><span class="o">();</span>
<span class="lineno">31</span>     <span class="o">}</span>
<span class="lineno">32</span> <span class="o">}</span></code></pre></div>

<p>啊哈，这就是为什么readers等待group能够连续获得锁的原因了，而且连续的unparkSuccessor也会导致多个线程同时进行doReleaseShared操作，reader线程被唤醒后head也会随着改变，这就是为什么需要for循环和CAS保证原子性还有用PROPAGATE标记head已经将successor唤醒的原因了</p>

<p>光是一个ReadLock就已经那么累了，下面进入WriteLock</p>

<hr />
<p>我们可以从ReadLock中看出一些蛛丝马迹，writers并不是共享的持有锁，一次只能有一个writer进行写操作。那么，WriteLock是不是会和我们之前认识的ReetrantLock(独占锁)大同小异呢？我们来探一探究竟</p>

<p>照例，还是从WriteLock的lock开始，它会调用Sync也就是AbstractQueuedSynchronizer里的acquire：</p>

<div class="highlight"><pre><code class="java"><span class="lineno"> 1</span> <span class="cm">/**</span>
<span class="lineno"> 2</span> <span class="cm"> * Acquires in exclusive mode, ignoring interrupts.  Implemented</span>
<span class="lineno"> 3</span> <span class="cm"> * by invoking at least once {@link #tryAcquire},</span>
<span class="lineno"> 4</span> <span class="cm"> * returning on success.  Otherwise the thread is queued, possibly</span>
<span class="lineno"> 5</span> <span class="cm"> * repeatedly blocking and unblocking, invoking {@link</span>
<span class="lineno"> 6</span> <span class="cm"> * #tryAcquire} until success.  This method can be used</span>
<span class="lineno"> 7</span> <span class="cm"> * to implement method {@link Lock#lock}.</span>
<span class="lineno"> 8</span> <span class="cm"> *</span>
<span class="lineno"> 9</span> <span class="cm"> * @param arg the acquire argument.  This value is conveyed to</span>
<span class="lineno">10</span> <span class="cm"> *        {@link #tryAcquire} but is otherwise uninterpreted and</span>
<span class="lineno">11</span> <span class="cm"> *        can represent anything you like.</span>
<span class="lineno">12</span> <span class="cm"> */</span>
<span class="lineno">13</span> <span class="kd">public</span> <span class="kd">final</span> <span class="kt">void</span> <span class="nf">acquire</span><span class="o">(</span><span class="kt">int</span> <span class="n">arg</span><span class="o">)</span> <span class="o">{</span>
<span class="lineno">14</span>     <span class="k">if</span> <span class="o">(!</span><span class="n">tryAcquire</span><span class="o">(</span><span class="n">arg</span><span class="o">)</span> <span class="o">&amp;&amp;</span>
<span class="lineno">15</span>         <span class="n">acquireQueued</span><span class="o">(</span><span class="n">addWaiter</span><span class="o">(</span><span class="n">Node</span><span class="o">.</span><span class="na">EXCLUSIVE</span><span class="o">),</span> <span class="n">arg</span><span class="o">))</span>
<span class="lineno">16</span>         <span class="n">selfInterrupt</span><span class="o">();</span>
<span class="lineno">17</span> <span class="o">}</span></code></pre></div>

<p>看到没有，这个之前ReentrantLock中调用的是同一个acquire方法，说明它是以独占的方式去获得锁的，不过具体的tryAcquire有一点点不同：</p>

<div class="highlight"><pre><code class="java"><span class="lineno"> 1</span> <span class="kd">protected</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">tryAcquire</span><span class="o">(</span><span class="kt">int</span> <span class="n">acquires</span><span class="o">)</span> <span class="o">{</span>
<span class="lineno"> 2</span>     <span class="cm">/*</span>
<span class="lineno"> 3</span> <span class="cm">     * Walkthrough:</span>
<span class="lineno"> 4</span> <span class="cm">     * 1. If read count nonzero or write count nonzero</span>
<span class="lineno"> 5</span> <span class="cm">     *    and owner is a different thread, fail.</span>
<span class="lineno"> 6</span> <span class="cm">     * 2. If count would saturate, fail. (This can only</span>
<span class="lineno"> 7</span> <span class="cm">     *    happen if count is already nonzero.)</span>
<span class="lineno"> 8</span> <span class="cm">     * 3. Otherwise, this thread is eligible for lock if</span>
<span class="lineno"> 9</span> <span class="cm">     *    it is either a reentrant acquire or</span>
<span class="lineno">10</span> <span class="cm">     *    queue policy allows it. If so, update state</span>
<span class="lineno">11</span> <span class="cm">     *    and set owner.</span>
<span class="lineno">12</span> <span class="cm">     */</span>
<span class="lineno">13</span>     <span class="n">Thread</span> <span class="n">current</span> <span class="o">=</span> <span class="n">Thread</span><span class="o">.</span><span class="na">currentThread</span><span class="o">();</span>
<span class="lineno">14</span>     <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">getState</span><span class="o">();</span>
<span class="lineno">15</span>     <span class="kt">int</span> <span class="n">w</span> <span class="o">=</span> <span class="n">exclusiveCount</span><span class="o">(</span><span class="n">c</span><span class="o">);</span>
<span class="lineno">16</span>     <span class="k">if</span> <span class="o">(</span><span class="n">c</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
<span class="lineno">17</span>         <span class="c1">// (Note: if c != 0 and w == 0 then shared count != 0)</span>
<span class="lineno">18</span>         <span class="k">if</span> <span class="o">(</span><span class="n">w</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">current</span> <span class="o">!=</span> <span class="n">getExclusiveOwnerThread</span><span class="o">())</span>
<span class="lineno">19</span>             <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
<span class="lineno">20</span>         <span class="k">if</span> <span class="o">(</span><span class="n">w</span> <span class="o">+</span> <span class="n">exclusiveCount</span><span class="o">(</span><span class="n">acquires</span><span class="o">)</span> <span class="o">&gt;</span> <span class="n">MAX_COUNT</span><span class="o">)</span>
<span class="lineno">21</span>             <span class="k">throw</span> <span class="k">new</span> <span class="nf">Error</span><span class="o">(</span><span class="s">&quot;Maximum lock count exceeded&quot;</span><span class="o">);</span>
<span class="lineno">22</span>         <span class="c1">// Reentrant acquire</span>
<span class="lineno">23</span>         <span class="n">setState</span><span class="o">(</span><span class="n">c</span> <span class="o">+</span> <span class="n">acquires</span><span class="o">);</span>
<span class="lineno">24</span>         <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
<span class="lineno">25</span>     <span class="o">}</span>
<span class="lineno">26</span>     <span class="k">if</span> <span class="o">(</span><span class="n">writerShouldBlock</span><span class="o">()</span> <span class="o">||</span>
<span class="lineno">27</span>         <span class="o">!</span><span class="n">compareAndSetState</span><span class="o">(</span><span class="n">c</span><span class="o">,</span> <span class="n">c</span> <span class="o">+</span> <span class="n">acquires</span><span class="o">))</span>
<span class="lineno">28</span>         <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
<span class="lineno">29</span>     <span class="n">setExclusiveOwnerThread</span><span class="o">(</span><span class="n">current</span><span class="o">);</span>
<span class="lineno">30</span>     <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
<span class="lineno">31</span> <span class="o">}</span></code></pre></div>

<p>过程还是比较清晰的，首先检查是否是readers占有锁，或者是已经有别的writer占有锁，如果上述情况成立，就会乖乖返回false去CLH里排队(没错，它不在这里插队)
如果是自己已经拿到了锁，那就会重入，返回true
如果当前没有人获得锁，就会进入writerShouldBlock()看看允不允许自己抢到这个锁，允许的话就CAS咯
我们来看看非公平模式的writerShouldBlock：</p>

<div class="highlight"><pre><code class="java"><span class="lineno">1</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">writerShouldBlock</span><span class="o">()</span> <span class="o">{</span>
<span class="lineno">2</span>     <span class="k">return</span> <span class="kc">false</span><span class="o">;</span> <span class="c1">// writers can always barge</span>
<span class="lineno">3</span> <span class="o">}</span></code></pre></div>

<p>我勒个去，这就是非公平的体现，直接返回false，那代表着无论CLH里有什么，当前线程都会尝试去CAS获得锁
来看看公平模式是怎么做的：</p>

<div class="highlight"><pre><code class="java"><span class="lineno">1</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">writerShouldBlock</span><span class="o">()</span> <span class="o">{</span>
<span class="lineno">2</span>     <span class="k">return</span> <span class="nf">hasQueuedPredecessors</span><span class="o">();</span>
<span class="lineno">3</span> <span class="o">}</span></code></pre></div>

<p>你看，它就公平多了，hasQueuedPredecessors就是看有没有已经有node在排队了，如果有的话，tryAcquire直接返回false了，没有才会尝试CAS
是不是跟ReentrantLock的招式师出同门的感觉呢。
再来看看unlock咯，最终也会调用AbstractQueuedSynchronizer的release，最后会调用Sync的tryRelease：</p>

<div class="highlight"><pre><code class="java"><span class="lineno"> 1</span> <span class="kd">protected</span> <span class="kd">final</span> <span class="kt">boolean</span> <span class="nf">tryRelease</span><span class="o">(</span><span class="kt">int</span> <span class="n">releases</span><span class="o">)</span> <span class="o">{</span>
<span class="lineno"> 2</span>     <span class="k">if</span> <span class="o">(!</span><span class="n">isHeldExclusively</span><span class="o">())</span>
<span class="lineno"> 3</span>         <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalMonitorStateException</span><span class="o">();</span>
<span class="lineno"> 4</span>     <span class="kt">int</span> <span class="n">nextc</span> <span class="o">=</span> <span class="n">getState</span><span class="o">()</span> <span class="o">-</span> <span class="n">releases</span><span class="o">;</span>
<span class="lineno"> 5</span>     <span class="kt">boolean</span> <span class="n">free</span> <span class="o">=</span> <span class="n">exclusiveCount</span><span class="o">(</span><span class="n">nextc</span><span class="o">)</span> <span class="o">==</span> <span class="mi">0</span><span class="o">;</span>
<span class="lineno"> 6</span>     <span class="k">if</span> <span class="o">(</span><span class="n">free</span><span class="o">)</span>
<span class="lineno"> 7</span>         <span class="n">setExclusiveOwnerThread</span><span class="o">(</span><span class="kc">null</span><span class="o">);</span>
<span class="lineno"> 8</span>     <span class="n">setState</span><span class="o">(</span><span class="n">nextc</span><span class="o">);</span>
<span class="lineno"> 9</span>     <span class="k">return</span> <span class="n">free</span><span class="o">;</span>
<span class="lineno">10</span> <span class="o">}</span></code></pre></div>

<p>我们会发现除了用exclusiveCount来计算writer的重入次数和ReentrantLock不同外，其他就是一毛一样</p>

<p>至此，我们论证了我们的结论，WriteLock就是一个独占模式，与ReetrantLock的逻辑几乎是一样的</p>

<h2 id="section"><em>总结</em></h2>
<p>纵观全文，无论是共享锁(ReadLock),还是独占锁(WriteLock), 它们都是通过一个状态用CAS来决定到底是不是拿到这个锁的，并且共享所和独占锁之间也是互斥的。我们也分析了公平模式和非公平模式的区别，一句话概括就是前者是FIFO而后者会优先考虑writer不会让他们等太久。等待队列还是有AbstractQueuedSynchronizer来维护。
至此，我们可以发现，锁这个东西，终究还是对一块内存的操作是否能成功以及这块内存的内容是否是由当前线程自己决定的，如果是，那当前线程就能获得所谓的”锁”，反之就是不能</p>

<p>最后问个问题，为什么ReetrantReadWriteLock中WriteLock可以降级为ReadLock但是反过来就不行呢？答案就在Sync中的tryAcquireShared和tryAcquire中～</p>


  </article>

</div>
      </div>
    </div>

    <footer class="site-footer">

  <div class="wrap">
	<div class="info">
      		<ul>
			<li>转载请注明出处<a class="this-link" href="http://moonfacex.github.io/blog/java/2016/04/05/reentrantreadwritelock.html">http://moonfacex.github.io/blog/java/2016/04/05/reentrantreadwritelock.html</a></li>
        		<li>如有疑问，可以微博私信我或者发邮件给我</li>
      		</ul>
    	</div>
    
    <div class="footer-col-1 column">
      <ul>
        <li>MoonfaceX</li>
        <li><a href="mailto:mr.moonfacex@gmail.com">mr.moonfacex@gmail.com</a></li>
      </ul>
    </div>

    <div class="footer-col-2 column">
      <ul>
        <li>
          <a href="https://github.com/MoonfaceX/moonface.github.io">
            <span class="icon github">
              <svg version="1.1" class="github-icon-svg" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
                 viewBox="0 0 16 16" enable-background="new 0 0 16 16" xml:space="preserve">
                <path fill-rule="evenodd" clip-rule="evenodd" fill="#C2C2C2" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761
                c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32
                c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472
                c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037
                C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65
                c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261
                c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082
                c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129
                c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/>
              </svg>
            </span>
            <span class="username"></span>
          </a>
        </li>
        <li>
	  <a href="http://weibo.com/u/1005421853"
            <span class="icon twitter">
              <svg version="1.1" class="twitter-icon-svg" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
                 viewBox="0 0 16 16" enable-background="new 0 0 16 16" xml:space="preserve">
                <path fill="#C2C2C2" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809
                c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27
                c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767
                c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206
                C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271
                c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469
                c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/>
              </svg>
            </span>
            <span class="username"></span>
          </a>
        </li>
      </ul>
    </div>

    <div class="footer-col-3 column">
      <p class="text">You'll never walk alone.</p>
    </div>

  </div>

</footer>


    </body>
</html>